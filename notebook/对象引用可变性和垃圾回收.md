### 对象引用/可变性和垃圾回收

把变量视作便利贴，为了理解 Python 中的赋值语句,应该始终先读右边。对象在右边创建或获
取,在此之后左边的变量才会绑定到对象上,这就像为对象贴上标注。

== 比较的是两个对象的值

is 比较的是对象的id是否相同，即对象的标识

is 运算符比 == 速度快,因为它不能重载,所以 Python 不用寻找并调用特殊方法,而是直接比较两个整数 ID。而 a == b 是语法糖,等同于 a.__eq__(b) 。

元组中不可变的是元素的标识。

对列表和其他可变序列来说,还能使用简洁的 l2 = l1[:] 语句创建副本。然而,构造方法或 [:] 做的是浅复制(即复制了最外层容器,副本中的元素是源容器中元素的引用)。如果所有元素都是不可变的,那么这样没有问题,还能节省内存。但是,如果有可变的元素,可能就会导致意想不到的问题。

不要使用可变类型作函数的默认参数

del 语句删除名称,而不是对象。 del 命令可能会导致对象被当作垃圾回收,但是仅当删除的变量保存的是对象的最后一个引用,或者无法得到对象时。   重新绑定也可能会导致对象的引用数量归零,导致对象被销毁。在 CPython 中,垃圾回收使用的主要算法是引用计数。

不可变集合不变的是所含对象的标识。

• 简单的赋值不创建副本。
• 对 += 或 *= 所做的增量赋值来说,如果左边的变量绑定的是不可变对象,会创建新对象;
如果是可变对象,会就地修改。
• 为现有的变量赋予新值,不会修改之前绑定的变量。这叫重新绑定:现在变量绑定了其
他对象。如果变量是之前那个对象的最后一个引用,对象会被当作垃圾回收。
• 函数的参数以别名的形式传递,这意味着,函数可能会修改通过参数传入的可变对象。
这一行为无法避免,除非在本地创建副本,或者使用不可变对象(例如,传入元组,而
不传入列表)。
• 使用可变类型作为函数参数的默认值有危险,因为如果就地修改了参数,默认值也就变
了,这会影响以后使用默认值的调用。

分代垃圾回收程序,它能把引用循环中不可获取的对象销毁。

