<!DOCTYPE html>
<!-- saved from url=(0070)https://baijiahao.baidu.com/s?id=1660009541007805174&wfr=spider&for=pc -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="referrer" content="always"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><link rel="shortcut icon" href="https://gss0.bdstatic.com/5bd1bjqh_Q23odCf/static/wiseindex/img/favicon64.ico" type="image/x-icon"><link rel="apple-touch-icon-precomposed" href="https://gss0.bdstatic.com/5bd1bjqh_Q23odCf/static/wiseindex/img/screen_icon_new.png"><title>搞懂这些Redis知识点，吊打面试官！</title><link rel="stylesheet" href="./搞懂这些Redis知识点，吊打面试官！_files/land_min_pack_34b2c65.css"><meta itemprop="dateUpdate" content="2020-03-02 18:43:47"></head><body style=""><script>/* eslint-disable */var s_domain = {"protocol":"https:","staticUrl":"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/","base":"","baseuri":"","passconf":"http://passport.baidu.com/ubrwsbas","logout":"https://passport.baidu.com/?logout&u=","bs":"https://www.baidu.com","sp":"http://hi.baidu.com/","ssllist":{"a.hiphotos.baidu.com":"ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy","b.hiphotos.baidu.com":"ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy","c.hiphotos.baidu.com":"ss3.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy","d.hiphotos.baidu.com":"ss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy","e.hiphotos.baidu.com":"ss1.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy","f.hiphotos.baidu.com":"ss2.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy","g.hiphotos.baidu.com":"ss3.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy","h.hiphotos.baidu.com":"ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy","1.su.bdimg.com":"ss0.bdstatic.com/k4oZeXSm1A5BphGlnYG","t10.baidu.com":"ss0.baidu.com/6ONWsjip0QIZ8tyhnq","t11.baidu.com":"ss1.baidu.com/6ONXsjip0QIZ8tyhnq","t12.baidu.com":"ss2.baidu.com/6ONYsjip0QIZ8tyhnq","himg.bdimg.com":"ss1.bdstatic.com/7Ls0a8Sm1A5BphGlnYG","cdn00.baidu-img.cn":"ss0.bdstatic.com/9bA1vGba2gU2pMbfm9GUKT-w","cdn01.baidu-img.cn":"ss0.bdstatic.com/9bA1vGfa2gU2pMbfm9GUKT-w"}};var s_session = {"ssid":"2267c33d","logid":"","sid":"1458_31669_21092","nid":"8924096194177168880","qid":""};var s_advert = {"isBjh":"1","contentUrl":"http://baijiahao.baidu.com/s?id=1660009541007805174","contentPlatformId":"3","contentType":"1","pvid":"51c3628036cd5ea8","time":"2020-05-16 15:36:21","contentAccType":"1","ctk":"7c77a986af83ff54","contentAccId":"PEPKElvbgdZdT9fcJIxwkA","ctk_b":"4ac579c6f79621b9","logid":"2181555266","dtime":"1589614581","grade":"3","createTimeAccLevel":"2"};</script><script>/* eslint-disable */var bds={se:{},su:{urdata:[],urSendClick:function(){},urStatic:"https://ss.bdimg.com"},util:{},use:{},comm:{domain:"",ubsurl:"",tn:"",queryEnc:"",queryId:"",inter:"",sugHost:"",query:"",qid:"",cid:"",sid:"",stoken:"",serverTime:"",user:"",username:"",loginAction:[],useFavo:"",pinyin:"",favoOn:"",curResultNum:"0",rightResultExist:false,protectNum:0,zxlNum:0,pageNum:1,pageSize:10,ishome:1,newindex:1}};var name,navigate,al_arr=[];var selfOpen=window.open;eval("var open = selfOpen;");var isIE=navigator.userAgent.indexOf("MSIE")!=-1&&!window.opera;var E=bds.ecom={};bds.se.mon={loadedItems:[],load:function(){},srvt:-1};try{bds.se.mon.srvt=parseInt(document.cookie.match(new RegExp("(^| )BDSVRTM=([^;]*)(;|$)"))[2]);document.cookie="BDSVRTM=;expires=Sat, 01 Jan 2000 00:00:00 GMT"}catch(e){}var bdUser=bds.comm.user?bds.comm.user:null,bdQuery=bds.comm.query,bdUseFavo=bds.comm.useFavo,bdFavoOn=bds.comm.favoOn,bdCid=bds.comm.cid,bdSid=bds.comm.sid,bdServerTime=bds.comm.serverTime,bdQid=bds.comm.queryId,bdstoken=bds.comm.stoken,login_success=[];</script><div id="detail-page"><div class="line-shadow"></div><div class="item-wrap"><div id="header_wrap" class="header_wrap"><div class="header_content"><div class="header_logo"><a href="https://www.baidu.com/" id="result_logo" data-clklog="tid:139;cst:2;logInfo:head_logo;" data-extralog="rid:;pos:;extra:;isBaiJiaHao:1;login:1;" data-rid="head_0"><img src="./搞懂这些Redis知识点，吊打面试官！_files/logo_top.png" alt="到百度首页" title="到百度首页"></a></div><div class="header_menu" data-rid="header_menu"><a href="https://www.baidu.com/" class="index" data-clklog="tid:142;cst:2;logInfo:head_menu" data-extralog="rid:;pos:;extra:;isBaiJiaHao:1;login:1;type:backindex" data-rid="head_1">百度首页</a><span class="line"></span><div id="userBlock" class="login" style="display: inline-block;"><a href="https://passport.baidu.com/v2/?login&amp;tpl=mn&amp;u=http://www.baidu.com" class="login" data-clklog="tid:142;cst:2;logInfo:head_menu;" data-extralog="rid:;pos:;extra:;isBaiJiaHao:1;login:1;type:login" data-rid="head_2">登录</a><a href="http://i.baidu.com/" id="usrname" class="usrname" data-clklog="tid:142;cst:2;logInfo:head_menu;" data-extralog="rid:;pos:;extra:;isBaiJiaHao:1;login:1;type:usrname;" data-rid="head_2"><span id="nametxt">小飞xiaofei33</span></a><div id="user_menu" data-showlog="tid:131;cst:1;logInfo:usrmenu;" data-extralog="rid:;pos:;extra:;isBaiJiaHao:1;login:1;" class="s-isindex-wrap s-user-set-menu menu-top" style="left: 1396.15px; display: none;"><a href="http://i.baidu.com/" id="usrname" class="usrname" data-clklog="tid:142;cst:2;logInfo:head_menu;" data-extralog="rid:;pos:;extra:;isBaiJiaHao:1;login:1;type:usrname;" data-rid="head_2"></a><div><a href="http://i.baidu.com/" id="usrname" class="usrname" data-clklog="tid:142;cst:2;logInfo:head_menu;" data-extralog="rid:;pos:;extra:;isBaiJiaHao:1;login:1;type:usrname;" data-rid="head_2"></a><a href="http://i.baidu.com/center" target="_blank" data-tid="1000" data-clklog="tid:146;cst:2;logInfo:usrmenu;" data-extralog="rid:;pos:1;extra:;isBaiJiaHao:1;login:1;type:center;" data-rid="usr_menu_1">个人中心</a><a href="http://passport.baidu.com/" data-tid="1001" target="_blank" data-clklog="tid:146;cst:2;logInfo:usrmenu;" data-extralog="rid:;pos:2;extra:;isBaiJiaHao:1;login:1;type:passport;" data-rid="usr_menu_2">帐号设置</a><a class="s-feedback" style="overflow:hidden" href="https://baijiahao.baidu.com/s?id=1660009541007805174&amp;wfr=spider&amp;for=pc#" onclick="return false;" data-clklog="tid:146;cst:2;logInfo:usrmenu;" data-extralog="rid:;pos:3;extra:;isBaiJiaHao:1;login:1;type:feedback;" data-rid="header_menu_3">意见反馈</a><a class="quit" style="overflow:hidden" href="https://passport.baidu.com/?logout&amp;u=https://www.baidu.com" data-clklog="tid:146;cst:2;logInfo:usrmenu;" data-extralog="rid:;pos:4;extra:;isBaiJiaHao:1;login:1;type:quit;" data-rid="usr_menu_4">退出</a></div><span class="menu-arrow"><em></em></span></div></div></div></div></div></div><div class="title_border"><div class="anci_header_content"><div class="article-title"><h2>搞懂这些Redis知识点，吊打面试官！</h2></div><div class="article-desc clearfix"><div class="author-icon"><img src="./搞懂这些Redis知识点，吊打面试官！_files/a9440eb633752a47bdeba1a089875033.jpeg"><i class="author-vip author-vip-10"></i></div><div class="author-txt"><p class="author-name">51CTO</p><div class="article-source article-source-bjh"><span class="date">发布时间：03-02</span><span class="time">18:43</span><span class="account-authentication"></span></div></div></div></div></div><div id="content-container" class="content-container clearfix" data-showlog="tid:126;cst:1;logInfo:landing;" data-extralog="flow:2;st:news;rid:8924096194177168880;pos:0;extra:;source:1;isBaijiahao:1;login:1;appId:1576672126808914;" data-ratio="1" data-rid="page"><div id="left-container" class="left-container"><div class="item-wrap"><div class="article " id="article" data-islow-browser="0"><div class="article-content"><p><span class="bjh-p">“今天，我不自量力的面试了某大厂的 Java 开发岗位，迎面走来一位风尘仆仆的中年男子，手里拿着屏幕还亮着的 Mac。</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/8601a18b87d6277ff2c9f6a246885436eb24fc8c.jpeg" data-loaded="0"></div><p><span class="bjh-p">图片来自 Pexels</span></p><p>他冲着我礼貌的笑了笑，然后说了句“不好意思，让你久等了”，然后示意我坐下，说：“我们开始吧，看了你的简历，觉得你对 Redis 应该掌握的不错，我们今天就来讨论下 Redis……”。我想：“来就来，兵来将挡水来土掩”。<span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p"><span class="bjh-strong">Redis 是什么</span></span></p><p><span class="bjh-p">面试官：你先来说下 Redis 是什么吧！</span></p><p><span class="bjh-p">我：（这不就是总结下 Redis 的定义和特点嘛）Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。</span></p><p><span class="bjh-p">它是一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库。</span></p><p><span class="bjh-p">我顿了一下，接着说，Redis 作为一个内存数据库：</span></p><p><span class="bjh-p">性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。单进程单线程，是线程安全的，采用 IO 多路复用机制。丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载。主从复制，哨兵，高可用。可以用作分布式锁。可以作为消息中间件使用，支持发布订阅。</span></p><p><span class="bjh-p"><span class="bjh-strong">五种数据类型</span></span></p><p><span class="bjh-p">面试官：总结的不错，看来是早有准备啊。刚来听你提到 Redis 支持五种数据类型，那你能简单说下这五种数据类型吗？</span></p><p><span class="bjh-p">我：当然可以，但是在说之前，我觉得有必要先来了解下 Redis 内部内存管理是如何描述这 5 种数据类型的。</span></p><p><span class="bjh-p">说着，我拿着笔给面试官画了一张图：</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/023b5bb5c9ea15ce598be46bdbb071f53b87b2a5.jpeg" data-loaded="0"></div><p><span class="bjh-p">我：首先 Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。</span></p><p><span class="bjh-p">redisObject 最主要的信息如上图所示：type 表示一个 value 对象具体是何种数据类型，encoding 是不同数据类型在 Redis 内部的存储方式。</span></p><p><span class="bjh-p">比如：type=string 表示 value 存储的是一个普通字符串，那么 encoding 可以是 raw 或者 int。</span></p><p><span class="bjh-p">我顿了一下，接着说，下面我简单说下 5 种数据类型：</span></p><p><span class="bjh-p">①String 是 Redis 最基本的类型，可以理解成与 Memcached一模一样的类型，一个 Key 对应一个 Value。Value 不仅是 String，也可以是数字。</span></p><p><span class="bjh-p">String 类型是二进制安全的，意思是 Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M。</span></p><p><span class="bjh-p">②Hash是一个键值（key-value）的集合。Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象。常用命令：hget，hset，hgetall 等。</span></p><p><span class="bjh-p">③List 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用命令：lpush、rpush、lpop、rpop、lrange（获取列表片段）等。</span></p><p><span class="bjh-p">应用场景：List 应用场景非常多，也是 Redis 最重要的数据结构之一，比如 Twitter 的关注列表，粉丝列表都可以用 List 结构来实现。</span></p><p><span class="bjh-p">数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。</span></p><p><span class="bjh-p">实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</span></p><p><span class="bjh-p">④Set 是 String 类型的无序集合。集合是通过 hashtable 实现的。Set 中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion 等。</span></p><p><span class="bjh-p">应用场景：Redis Set 对外提供的功能和 List 一样是一个列表，特殊之处在于 Set 是自动去重的，而且 Set 提供了判断某个成员是否在一个 Set 集合中。</span></p><p><span class="bjh-p">⑤Zset 和 Set 一样是 String 类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard 等。</span></p><p><span class="bjh-p">使用场景：Sorted Set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。</span></p><p><span class="bjh-p">当你需要一个有序的并且不重复的集合列表，那么可以选择 Sorted Set 结构。</span></p><p><span class="bjh-p">和 Set 相比，Sorted Set关联了一个 Double 类型权重的参数 Score，使得集合中的元素能够按照 Score 进行有序排列，Redis 正是通过分数来为集合中的成员进行从小到大的排序。</span></p><p><span class="bjh-p">实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。</span></p><p><span class="bjh-p">而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 Score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</span></p><p><span class="bjh-p">数据类型应用场景总结：</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/7a899e510fb30f24c7a97030a6259a45ad4b030c.png" data-loaded="0"></div><p><span class="bjh-p">面试官：想不到你平时也下了不少工夫，那 Redis 缓存你一定用过的吧？</span></p><p><span class="bjh-p">我：用过的。</span></p><p><span class="bjh-p">面试官：那你跟我说下你是怎么用的？</span></p><p><span class="bjh-p">我是结合 Spring Boot 使用的。一般有两种方式，一种是直接通过 RedisTemplate 来使用，另一种是使用 Spring Cache 集成 Redis（也就是注解的方式）。</span></p><p><span class="bjh-p"><span class="bjh-strong">Redis 缓存</span></span></p><p><span class="bjh-p">直接通过 RedisTemplate 来使用，使用 Spring Cache 集成 Redis pom.xml 中加入以下依赖：</span></p><p><span class="bjh-p">&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;&lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;</span></p><p><span class="bjh-p">spring-boot-starter-data-redis：在 Spring Boot 2.x 以后底层不再使用 Jedis，而是换成了 Lettuce。</span></p><p><span class="bjh-p">commons-pool2：用作 Redis 连接池，如不引入启动会报错。</span></p><p><span class="bjh-p">spring-session-data-redis：Spring Session 引入，用作共享 Session。</span></p><p><span class="bjh-p">配置文件 application.yml 的配置：</span></p><p><span class="bjh-p">server:  port: 8082  servlet:    session:      timeout: 30msspring:cache:type: redis  redis:    host: 127.0.0.1    port: 6379password:# redis默认情况下有16个分片，这里配置具体使用的分片，默认为0database: 0    lettuce:      pool:# 连接池最大连接数(使用负数表示没有限制),默认8max-active: 100</span></p><p><span class="bjh-p">创建实体类 User.java：</span></p><p><span class="bjh-p">publicclassUserimplementsSerializable{privatestaticfinallong serialVersionUID = 662692455422902539L;private Integer id;private String name;private Integer age;publicUser(){    }publicUser(Integer id, String name, Integer age){this.id = id;this.name = name;this.age = age;    }public Integer getId(){return id;    }publicvoidsetId(Integer id){this.id = id;    }public String getName(){return name;    }publicvoidsetName(String name){this.name = name;    }public Integer getAge(){return age;    }publicvoidsetAge(Integer age){this.age = age;    }@Overridepublic String toString(){return"User{" +"id=" + id +", name='" + name + '\'' +", age=" + age +'}';    }}</span></p><p><span class="bjh-p">RedisTemplate 的使用方式</span></p><p><span class="bjh-p">默认情况下的模板只能支持 RedisTemplate&lt;String, String&gt;，也就是只能存入字符串，所以自定义模板很有必要。</span></p><p><span class="bjh-p">添加配置类 RedisCacheConfig.java：</span></p><p><span class="bjh-p">@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)publicclassRedisCacheConfig {    @Beanpublic RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate(LettuceConnectionFactory connectionFactory) {        RedisTemplate&lt;String, Serializable&gt; template = new RedisTemplate&lt;&gt;();template.setKeySerializer(new StringRedisSerializer());template.setValueSerializer(new GenericJackson2JsonRedisSerializer());template.setConnectionFactory(connectionFactory);returntemplate;    }}</span></p><p><span class="bjh-p">测试类：</span></p><p><span class="bjh-p">@RestController@RequestMapping("/user")publicclassUserController{public static Logger logger = LogManager.getLogger(UserController.class);@Autowiredprivate StringRedisTemplate stringRedisTemplate;@Autowiredprivate RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;@RequestMapping("/test")public void test() {        redisCacheTemplate.opsForValue().set("userkey", new User(1, "张三", 25));        User user = (User) redisCacheTemplate.opsForValue().get("userkey");        logger.info("当前获取对象：{}", user.toString());    }</span></p><p><span class="bjh-p">然后在浏览器访问，观察后台日志 http://localhost:8082/user/test</span></p><p><span class="bjh-p">使用 Spring Cache 集成 Redis</span></p><p><span class="bjh-p">Spring Cache 具备很好的灵活性，不仅能够使用 SPEL（spring expression language）来定义缓存的 Key 和各种 Condition，还提供了开箱即用的缓存临时存储方案，也支持和主流的专业缓存如 EhCache、Redis、Guava 的集成。</span></p><p><span class="bjh-p">定义接口 UserService.java：</span></p><p><span class="bjh-p">publicinterfaceUserService {User save(User user);voiddelete(int id);User get(Integer id);}</span></p><p><span class="bjh-p">接口实现类 UserServiceImpl.java：</span></p><p><span class="bjh-p">@ServicepublicclassUserServiceImplimplementsUserService{publicstatic Logger logger = LogManager.getLogger(UserServiceImpl.class);privatestatic Map&lt;Integer, User&gt; userMap = new HashMap&lt;&gt;();static {        userMap.put(1, new User(1, "肖战", 25));        userMap.put(2, new User(2, "王一博", 26));        userMap.put(3, new User(3, "杨紫", 24));    }@CachePut(value ="user", key = "#user.id")@Overridepublic User save(User user){        userMap.put(user.getId(), user);        logger.info("进入save方法，当前存储对象：{}", user.toString());return user;    }@CacheEvict(value="user", key = "#id")@Overridepublicvoiddelete(int id){        userMap.remove(id);        logger.info("进入delete方法，删除成功");    }@Cacheable(value = "user", key = "#id")@Overridepublic User get(Integer id){        logger.info("进入get方法，当前获取对象：{}", userMap.get(id)==null?null:userMap.get(id).toString());return userMap.get(id);    }}</span></p><p><span class="bjh-p">为了方便演示数据库的操作，这里直接定义了一个 Map&lt;Integer,User&gt; userMap。</span></p><p><span class="bjh-p">这里的核心是三个注解：</span></p><p><span class="bjh-p">@Cachable@CachePut@CacheEvict</span></p><p><span class="bjh-p">测试类：UserController</span></p><p><span class="bjh-p">@RestController@RequestMapping("/user")publicclassUserController{publicstatic Logger logger = LogManager.getLogger(UserController.class);@Autowiredprivate StringRedisTemplate stringRedisTemplate;@Autowiredprivate RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;@Autowiredprivate UserService userService;@RequestMapping("/test")publicvoidtest(){        redisCacheTemplate.opsForValue().set("userkey", new User(1, "张三", 25));        User user = (User) redisCacheTemplate.opsForValue().get("userkey");        logger.info("当前获取对象：{}", user.toString());    }@RequestMapping("/add")publicvoidadd(){        User user = userService.save(new User(4, "李现", 30));        logger.info("添加的用户信息：{}",user.toString());    }@RequestMapping("/delete")publicvoiddelete(){        userService.delete(4);    }@RequestMapping("/get/{id}")publicvoidget(@PathVariable("id") String idStr) throws Exception{if (StringUtils.isBlank(idStr)) {thrownew Exception("id为空");        }        Integer id = Integer.parseInt(idStr);        User user = userService.get(id);        logger.info("获取的用户信息：{}",user.toString());    }}</span></p><p><span class="bjh-p">用缓存要注意，启动类要加上一个注解开启缓存：</span></p><p><span class="bjh-p">@SpringBootApplication(exclude=DataSourceAutoConfiguration.class)@EnableCachingpublicclassApplication{publicstaticvoidmain(String[] args){        SpringApplication.run(Application.class, args);    }}</span></p><p><span class="bjh-p">①先调用添加接口：http://localhost:8082/user/add</span></p><p><span class="bjh-p">②再调用查询接口，查询 id=4 的用户信息：</span></p><p><span class="bjh-p">可以看出，这里已经从缓存中获取数据了，因为上一步 add 方法已经把 id=4 的用户数据放入了 Redis 缓存 3、调用删除方法，删除 id=4 的用户信息，同时清除缓存：</span></p><p><span class="bjh-p">④再次调用查询接口，查询 id=4 的用户信息：</span></p><p><span class="bjh-p">没有了缓存，所以进入了 get 方法，从 userMap 中获取。</span></p><p><span class="bjh-p">缓存注解</span></p><p><span class="bjh-p">①@Cacheable</span></p><p><span class="bjh-p">根据方法的请求参数对其结果进行缓存：</span></p><p><span class="bjh-p">Key：缓存的 Key，可以为空，如果指定要按照 SPEL 表达式编写，如果不指定，则按照方法的所有参数进行组合。Value：缓存的名称，必须指定至少一个（如 @Cacheable (value='user')或者 @Cacheable(value={'user1','user2'})）Condition：缓存的条件，可以为空，使用 SPEL 编写，返回 true 或者 false，只有为 true 才进行缓存。</span></p><p><span class="bjh-p">②@CachePut</span></p><p><span class="bjh-p">根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用。参数描述见上。</span></p><p><span class="bjh-p">③@CacheEvict</span></p><p><span class="bjh-p">根据条件对缓存进行清空：</span></p><p><span class="bjh-p">Key：同上。Value：同上。Condition：同上。allEntries：是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。beforeInvocation：是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存。缺省情况下，如果方法执行抛出异常，则不会清空缓存。</span></p><p><span class="bjh-p">缓存问题</span></p><p><span class="bjh-p">面试官：看了一下你的 Demo，简单易懂。那你在实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？</span></p><p><span class="bjh-p">我：缓存和数据库数据一致性问题：分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。</span></p><p><span class="bjh-p">我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。</span></p><p><span class="bjh-p">合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</span></p><p><span class="bjh-p">面试官：Redis 雪崩了解吗？</span></p><p><span class="bjh-p">我：我了解的，目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。</span></p><p><span class="bjh-p">举个栗子：如果首页所有 Key 的失效时间都是 12 小时，中午 12 点刷新的，我零点有个大促活动大量用户涌入，假设每秒 6000 个请求，本来缓存可以抗住每秒 5000 个请求，但是缓存中所有 Key 都失效了。</span></p><p><span class="bjh-p">此时 6000 个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能 DBA 都没反应过来直接挂了。</span></p><p><span class="bjh-p">此时，如果没什么特别的方案来处理，DBA 很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。</span></p><p><span class="bjh-p">我心想：同一时间大面积失效，瞬间 Redis 跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的。</span></p><p><span class="bjh-p">你想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错。</span></p><p><span class="bjh-p">如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了，临睡之前，骂骂咧咧“什么垃圾产品”。</span></p><p><span class="bjh-p">面试官摸摸了自己的头发：嗯，还不错，那这种情况你都是怎么应对的？</span></p><p><span class="bjh-p">我：处理缓存雪崩简单，在批量往 Redis 存数据的时候，把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。</span></p><p><span class="bjh-p">setRedis（key, value, time+Math.random()*10000）;</span></p><p><span class="bjh-p">如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。</span></p><p><span class="bjh-p">或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</span></p><p><span class="bjh-p">面试官：那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别吗？</span></p><p><span class="bjh-p">我：嗯，了解，先说下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求。</span></p><p><span class="bjh-p">举个栗子：我们数据库的 id 都是从 1 自增的，如果发起 id=-1 的数据或者 id 特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。</span></p><p><span class="bjh-p">我又接着说：至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了 DB。</span></p><p><span class="bjh-p">而缓存击穿不同的是缓存击穿是指一个 Key 非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个 Key 在失效的瞬间，持续的大并发直接落到了数据库上，就在这个 Key 的点上击穿了缓存。</span></p><p><span class="bjh-p">面试官露出欣慰的眼光：那他们分别怎么解决？</span></p><p><span class="bjh-p">我：缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接 return，比如 id 做基础校验，id&lt;=0 直接拦截。</span></p><p><span class="bjh-p">面试官：那你还有别的方法吗？</span></p><p><span class="bjh-p">我：我记得 Redis 里还有一个高级用法布隆过滤器（Bloom Filter）这个也能很好的预防缓存穿透的发生。</span></p><p><span class="bjh-p">它的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个 Key 是否在数据库中存在，不存在你 return 就好了，存在你就去查 DB 刷新 KV 再 return。</span></p><p><span class="bjh-p">缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。作为暖男，代码给你准备好了，拿走不谢。</span></p><p><span class="bjh-p">publicstatic String getData(String key)throws InterruptedException {//从Redis查询数据        String result = getDataByKV(key);//参数校验if (StringUtils.isBlank(result)) {try {//获得锁if (reenLock.tryLock()) {//去数据库查询                    result = getDataByDB(key);//校验if (StringUtils.isNotBlank(result)) {//插进缓存                        setDataToKV(key, result);                    }                } else {//睡一会再拿                    Thread.sleep(100L);                    result = getData(key);                }            } finally {//释放锁                reenLock.unlock();            }        }return result;    }</span></p><p><span class="bjh-p">面试官：嗯嗯，还不错。</span></p><p><span class="bjh-p"><span class="bjh-strong">Redis 为何这么快</span></span></p><p><span class="bjh-p">面试官：Redis 作为缓存大家都在用，那 Redis 一定很快咯？</span></p><p><span class="bjh-p">我：当然了，官方提供的数据可以达到 100000+ 的 QPS（每秒内的查询次数），这个数据不比 Memcached 差！</span></p><p><span class="bjh-p">面试官：Redis 这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）</span></p><p><span class="bjh-p">我：您是想问 Redis 这么快，为什么还是单线程的吧。Redis 确实是单进程单线程的模型，因为 Redis 完全是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</span></p><p><span class="bjh-p">既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。</span></p><p><span class="bjh-p">面试官：嗯，是的。那你能说说 Redis 是单线程的，为什么还能这么快吗？</span></p><p><span class="bjh-p">我：可以这么说吧，总结一下有如下四点：</span></p><p><span class="bjh-p">Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度是 O(1)。数据结构简单，对数据操作也简单。采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的 CPU 切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。使用多路复用 IO 模型，非阻塞 IO。</span></p><p><span class="bjh-p">Redis 和 Memcached 的区别</span></p><p><span class="bjh-p">面试官：嗯嗯，说的很详细。那你为什么选择 Redis 的缓存方案而不用 Memcached 呢？</span></p><p><span class="bjh-p">我：原因有如下四点：</span></p><p><span class="bjh-p">存储方式上：Memcache 会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分数据存在硬盘上，这样能保证数据的持久性。数据支持类型上：Memcache 对数据类型的支持简单，只支持简单的 key-value，，而 Redis 支持五种数据类型。使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。Value 的大小：Redis 可以达到 1GB，而 Memcache 只有 1MB。</span></p><p><span class="bjh-p"><span class="bjh-strong">淘汰策略</span></span></p><p><span class="bjh-p">面试官：那你说说你知道的 Redis 的淘汰策略有哪些？</span></p><p><span class="bjh-p">我：Redis 有六种淘汰策略，如下图：</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/6a600c338744ebf83ba823bbb4499c2c6259a78b.png" data-loaded="0"></div><p><span class="bjh-p">补充一下：Redis 4.0 加入了 LFU（least frequency use）淘汰策略，包括 volatile-lfu 和 allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的 KV 淘汰。</span></p><p><span class="bjh-p"><span class="bjh-strong">持久化</span></span></p><p><span class="bjh-p">面试官：你对 Redis 的持久化机制了解吗？能讲一下吗？</span></p><p><span class="bjh-p">我：Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。</span></p><p><span class="bjh-p">Redis 的持久化策略有两种：</span></p><p><span class="bjh-p">RDB：快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。AOF：把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。Redis 默认是快照 RDB 的持久化方式。</span></p><p><span class="bjh-p">当 Redis 重启的时候，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。</span></p><p><span class="bjh-p">面试官：那你再说下 RDB 是怎么工作的？</span></p><p><span class="bjh-p">我：默认 Redis 是会以快照"RDB"的形式将数据持久化到磁盘的一个二进制文件 dump.rdb。</span></p><p><span class="bjh-p">工作原理简单说一下：当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。</span></p><p><span class="bjh-p">当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处是可以 copy-on-write。</span></p><p><span class="bjh-p">我：RDB 的优点是：这种文件非常适合用于备份：比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。</span></p><p><span class="bjh-p">这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适合灾难恢复。</span></p><p><span class="bjh-p">RDB 的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。</span></p><p><span class="bjh-p">面试官：那你要不再说下 AOF？</span></p><p><span class="bjh-p">我：（说就一起说下吧）使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 appendonly.aof 中，配置方式如下：</span></p><p><span class="bjh-p">appendfsyncyesappendfsync always     #每次有数据修改发生时都会写入AOF文件。appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。</span></p><p><span class="bjh-p">AOF 可以做到全程持久化，只需要在配置中开启 appendonly yes。这样 Redis 每执行一个修改数据的命令，都会把它添加到 AOF 文件中，当 Redis 重启时，将会读取 AOF 文件进行重放，恢复到 Redis 关闭前的最后时刻。</span></p><p><span class="bjh-p">我顿了一下，继续说：使用 AOF 的优点是会让 Redis 变得非常耐久。可以设置不同的 Fsync 策略，AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。</span></p><p><span class="bjh-p">缺点是对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。</span></p><p><span class="bjh-p">面试官又问：你说了这么多，那我该用哪一个呢？</span></p><p><span class="bjh-p">我：如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用 RDB 持久。</span></p><p><span class="bjh-p">AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。</span></p><p><span class="bjh-p">数据库备份和灾难恢复：定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。</span></p><p><span class="bjh-p">当然了，Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。</span></p><p><span class="bjh-p"><span class="bjh-strong">主从复制</span></span></p><p><span class="bjh-p">面试官：Redis 单节点存在单点故障问题，为了解决单点问题，一般都需要对 Redis 配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，你能说说 Redis 主从复制的过程和原理吗？</span></p><p><span class="bjh-p">我有点懵，这个说来就话长了。但幸好提前准备了：主从配置结合哨兵模式能解决单点故障问题，提高 Redis 可用性。</span></p><p><span class="bjh-p">从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</span></p><p><span class="bjh-p">我顿了一下，接着说：关于复制过程，是这样的：</span></p><p><span class="bjh-p">从节点执行 slaveof[masterIP][masterPort]，保存主节点信息。从节点中的定时任务发现主节点信息，建立和主节点的 Socket 连接。从节点发送 Ping 信号，主节点返回 Pong，两边能互相通信。连接建立后，主节点将所有数据发送给从节点（数据同步）。主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</span></p><p><span class="bjh-p">面试官：那你能详细说下数据同步的过程吗？</span></p><p><span class="bjh-p">（我心想：这也问的太细了吧）我：可以。Redis 2.8 之前使用 sync[runId][offset] 同步命令，Redis 2.8 之后使用 psync[runId][offset] 命令。</span></p><p><span class="bjh-p">两者不同在于，Sync 命令仅支持全量复制过程，Psync 支持全量和部分复制。</span></p><p><span class="bjh-p">介绍同步之前，先介绍几个概念：</span></p><p><span class="bjh-p">runId：每个 Redis 节点启动都会生成唯一的 uuid，每次 Redis 重启后，runId 都会发生变化。offset：主节点和从节点都各自维护自己的主从复制偏移量 offset，当主节点有写入命令时，offset=offset+命令的字节长度。从节点在收到主节点发送的命令后，也会增加自己的 offset，并把自己的 offset 发送给主节点。这样，主节点同时保存自己的 offset 和从节点的 offset，通过对比 offset 来判断主从节点数据是否一致。repl_backlog_size：保存在主节点上的一个固定长度的先进先出队列，默认大小是 1MB。</span></p><p><span class="bjh-p">主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。</span></p><p><span class="bjh-p">从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制。</span></p><p><span class="bjh-p">主节点响应写命令时，不但会把命名发送给从节点，还会写入复制积压缓冲区，用于复制命令丢失的数据补救。</span></p><div class="img-container"><img class="normal" width="452px" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/80cb39dbb6fd5266f986f251c6a8dc2dd5073678.jpeg" data-loaded="0"></div><p><span class="bjh-p">上面是 Psync 的执行流程，从节点发送 psync[runId][offset] 命令，主节点有三种响应：</span></p><p><span class="bjh-p">FULLRESYNC：第一次连接，进行全量复制CONTINUE：进行部分复制ERR：不支持 psync 命令，进行全量复制</span></p><p><span class="bjh-p">面试官：很好，那你能具体说下全量复制和部分复制的过程吗？</span></p><p><span class="bjh-p">我：可以！</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/060828381f30e924128e13dd20b825001c95f76f.jpeg" data-loaded="0"></div><p><span class="bjh-p">上面是全量复制的流程。主要有以下几步：</span></p><p><span class="bjh-p">从节点发送 psync ? -1 命令（因为第一次发送，不知道主节点的 runId，所以为?，因为是第一次复制，所以 offset=-1）。主节点发现从节点是第一次复制，返回 FULLRESYNC {runId} {offset}，runId 是主节点的 runId，offset 是主节点目前的 offset。从节点接收主节点信息后，保存到 info 中。主节点在发送 FULLRESYNC 后，启动 bgsave 命令，生成 RDB 文件（数据持久化）。主节点发送 RDB 文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区。从节点清理自己的数据库数据。从节点加载 RDB 文件，将数据保存到自己的数据库中。如果从节点开启了 AOF，从节点会异步重写 AOF 文件。</span></p><p><span class="bjh-p">关于部分复制有以下几点说明：</span></p><p><span class="bjh-p">①部分复制主要是 Redis 针对全量复制的过高开销做出的一种优化措施，使用 psync[runId][offset] 命令实现。</span></p><p><span class="bjh-p">当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制积压缓冲区将这部分数据直接发送给从节点。</span></p><p><span class="bjh-p">这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。</span></p><p><span class="bjh-p">②主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据。</span></p><p><span class="bjh-p">③当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行 ID。因此会把它们当做 psync 参数发送给主节点，要求进行部分复制。</span></p><p><span class="bjh-p">④主节点接收到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点。</span></p><p><span class="bjh-p">之后根据参数 offset 在复制积压缓冲区中查找，如果 offset 之后的数据存在，则对从节点发送+COUTINUE 命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。</span></p><p><span class="bjh-p">⑤主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</span></p><p><span class="bjh-p"><span class="bjh-strong">哨兵</span></span></p><p><span class="bjh-p">面试官：那主从复制会存在哪些问题呢？</span></p><p><span class="bjh-p">我：主从复制会存在以下问题：</span></p><p><span class="bjh-p">一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。主节点的写能力受到单机的限制。主节点的存储能力受到单机的限制。原生复制的弊端在早期的版本中也会比较突出，比如：Redis 复制中断后，从节点会发起 psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</span></p><p><span class="bjh-p">面试官：那比较主流的解决方案是什么呢？</span></p><p><span class="bjh-p">我：当然是哨兵啊。</span></p><p><span class="bjh-p">面试官：那么问题又来了。那你说下哨兵有哪些功能？</span></p><div class="img-container"><img class="normal" width="478px" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/a2cc7cd98d1001e963a8484cd5be30ea55e79717.jpeg" data-loaded="0"></div><p><span class="bjh-p">我：如图，是 Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。</span></p><p><span class="bjh-p">Redis Sentinel 最小配置是一主一从。Redis 的 Sentinel 系统可以用来管理多个 Redis 服务器。</span></p><p><span class="bjh-p">该系统可以执行以下四个任务：</span></p><p><span class="bjh-p">监控：不断检查主服务器和从服务器是否正常运行。通知：当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他应用程序发出通知。自动故障转移：当主节点不能正常工作时，Sentinel 会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。配置提供者：在 Redis Sentinel 模式下，客户端应用在初始化时连接的是 Sentinel 节点集合，从中获取主节点的信息。</span></p><p><span class="bjh-p">面试官：那你能说下哨兵的工作原理吗？</span></p><p><span class="bjh-p">我：话不多说，直接上图：</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/4e4a20a4462309f7774c05db1fbe47f5d6cad60b.jpeg" data-loaded="0"></div><p><span class="bjh-p">①每个 Sentinel 节点都需要定期执行以下任务：每个 Sentinel 以每秒一次的频率，向它所知的主服务器、从服务器以及其他的 Sentinel 实例发送一个 PING 命令。（如上图）</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/060828381f30e924847d8f4b22b825001c95f721.jpeg" data-loaded="0"></div><p><span class="bjh-p">②如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为主观下线。（如上图）</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/29381f30e924b899a336158100b656930b7bf6b3.jpeg" data-loaded="0"></div><p><span class="bjh-p">③如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有 Sentinel 节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/dcc451da81cb39dbb22e4c53bda64222aa18307a.jpeg" data-loaded="0"></div><p><span class="bjh-p">④如果一个主服务器被标记为主观下线，并且有足够数量的 Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/e61190ef76c6a7eff4d30744904ae457f2de6615.jpeg" data-loaded="0"></div><p><span class="bjh-p">⑤一般情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。</span></p><p><span class="bjh-p">当一个主服务器被标记为客观下线时，Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率，会从 10 秒一次改为每秒一次。</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/810a19d8bc3eb1355e3e0874caaee3d5ff1f44be.jpeg" data-loaded="0"></div><p><span class="bjh-p">⑥Sentinel 和其他 Sentinel 协商客观下线的主节点的状态，如果处于 SDOWN 状态，则投票自动选出新的主节点，将剩余从节点指向新的主节点进行数据复制。</span></p><div class="img-container"><img class="large" data-loadfunc="0" src="./搞懂这些Redis知识点，吊打面试官！_files/241f95cad1c8a786d4c49a970ab9823b72cf50f7.jpeg" data-loaded="0"></div><p><span class="bjh-p">⑦当没有足够数量的 Sentinel 同意主服务器下线时，主服务器的客观下线状态就会被移除。</span></p><p><span class="bjh-p">当主服务器重新向 Sentinel 的 PING 命令返回有效回复时，主服务器的主观下线状态就会被移除。</span></p><p><span class="bjh-p">面试官：不错，面试前没少下工夫啊，今天 Redis 这关你过了，明天找个时间我们再聊聊其他的。（露出欣慰的微笑）</span></p><p><span class="bjh-p">我：没问题。</span></p><p><span class="bjh-p"><span class="bjh-strong">总结</span></span></p><p><span class="bjh-p">本文在一次面试的过程中讲述了 Redis 是什么，Redis 的特点和功能，Redis 缓存的使用，Redis 为什么能这么快，Redis 缓存的淘汰策略，持久化的两种方式，Redis 高可用部分的主从复制和哨兵的基本原理。</span></p></div><audio height="0" width="0" id="musicAudio" data-play-index=""><source></audio></div></div></div><div id="right-container" class="right-container"><div class="item-wrap"><div class="recent-article" data-pos=""><h2>作者最新文章<ul><li data-showlog="tid:135;cst:1;logInfo:recent_article;" data-extralog="rid:;pos:0;extra:;isBaiJiaHao:1;login:1;" data-rid="recent_article_0"><h3 class="item-title"><a href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9464380012007354347%22%7D&amp;n_type=1&amp;p_from=3" data-clklog="tid:147;cst:2;logInfo:recent_article;" data-extralog="rid:;pos:0;extra:;isBaiJiaHao:1;login:1;" target="_blank">如何在Linux中查找硬盘的详细信息？</a></h3><div class="item-desc hide"><span class="info-date">05-15</span><span class="info-time">10:16</span></div></li><li data-showlog="tid:135;cst:1;logInfo:recent_article;" data-extralog="rid:;pos:1;extra:;isBaiJiaHao:1;login:1;" data-rid="recent_article_1"><h3 class="item-title"><a href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_10117496584870532358%22%7D&amp;n_type=1&amp;p_from=3" data-clklog="tid:147;cst:2;logInfo:recent_article;" data-extralog="rid:;pos:1;extra:;isBaiJiaHao:1;login:1;" target="_blank">如何选择云物联网平台？</a></h3><div class="item-desc hide"><span class="info-date">05-15</span><span class="info-time">10:00</span></div></li><li data-showlog="tid:135;cst:1;logInfo:recent_article;" data-extralog="rid:;pos:2;extra:;isBaiJiaHao:1;login:1;" data-rid="recent_article_2"><h3 class="item-title"><a href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9641141066106104040%22%7D&amp;n_type=1&amp;p_from=3" data-clklog="tid:147;cst:2;logInfo:recent_article;" data-extralog="rid:;pos:2;extra:;isBaiJiaHao:1;login:1;" target="_blank">一行脚本，几TB的数据没有了……</a></h3><div class="item-desc hide"><span class="info-date">05-15</span><span class="info-time">09:18</span></div></li></ul></h2></div></div><div class="item-wrap"><div class="related-news"><div class="news-content "><h2>相关文章</h2><ul><li data-showlog="tid:136;cst:1;logInfo:related_news;" data-extralog="flow:2;rid:;pos:0;extra:;isBaiJiaHao:1;login:1;" data-rid="related_news_0"><div class="item-content clearfix"><div class="news-info"><div class="news-title"><h3><a class="upgrade" data-clklog="tid:148;cst:2;logInfo:related_news;" data-extralog="rid:;pos:0;extra:;isBaiJiaHao:1;login:1;type:&#39;title&#39;" href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_8804957525223155272%22%7D&amp;n_type=1&amp;p_from=4" target="_blank">如何用编程器将程序写到单片机里？看完你会绝对一点都不难</a></h3></div></div><div class="news-pic"><a class="upgrade" data-clklog="tid:148;cst:2;logInfo:related_news;" data-extralog="rid:;pos:1;extra:;isBaiJiaHao:1;login:1;type:&#39;img&#39;" href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_8804957525223155272%22%7D&amp;n_type=1&amp;p_from=4" target="_blank"><img src="./搞懂这些Redis知识点，吊打面试官！_files/u=3600043234,3649141187&amp;fm=173&amp;app=49&amp;f=JPEG"></a></div></div></li><li data-showlog="tid:136;cst:1;logInfo:related_news;" data-extralog="flow:2;rid:;pos:1;extra:;isBaiJiaHao:1;login:1;" data-rid="related_news_1"><div class="item-content clearfix"><div class="news-info"><div class="news-title"><h3><a class="upgrade" data-clklog="tid:148;cst:2;logInfo:related_news;" data-extralog="rid:;pos:1;extra:;isBaiJiaHao:1;login:1;type:&#39;title&#39;" href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9599977236282303888%22%7D&amp;n_type=1&amp;p_from=4" target="_blank">微软与 Redis Labs 达成合作，以改善 Redis 的 Azure 缓存</a></h3></div></div><div class="news-pic"><a class="upgrade" data-clklog="tid:148;cst:2;logInfo:related_news;" data-extralog="rid:;pos:2;extra:;isBaiJiaHao:1;login:1;type:&#39;img&#39;" href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9599977236282303888%22%7D&amp;n_type=1&amp;p_from=4" target="_blank"><img src="./搞懂这些Redis知识点，吊打面试官！_files/u=3884211643,1769195388&amp;fm=173&amp;app=49&amp;f=JPEG"></a></div></div></li><li data-showlog="tid:136;cst:1;logInfo:related_news;" data-extralog="flow:2;rid:;pos:2;extra:;isBaiJiaHao:1;login:1;" data-rid="related_news_2"><div class="item-content clearfix"><div class="news-info"><div class="news-title"><h3><a class="upgrade" data-clklog="tid:148;cst:2;logInfo:related_news;" data-extralog="rid:;pos:2;extra:;isBaiJiaHao:1;login:1;type:&#39;title&#39;" href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9498874844370810587%22%7D&amp;n_type=1&amp;p_from=4" target="_blank">人民银行娄底市中心支行到娄底农商银行开展反“电诈”督查</a></h3></div></div><div class="news-pic"><a class="upgrade" data-clklog="tid:148;cst:2;logInfo:related_news;" data-extralog="rid:;pos:3;extra:;isBaiJiaHao:1;login:1;type:&#39;img&#39;" href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9498874844370810587%22%7D&amp;n_type=1&amp;p_from=4" target="_blank"><img src="./搞懂这些Redis知识点，吊打面试官！_files/u=170808130,1634918376&amp;fm=173&amp;app=49&amp;f=JPEG"></a></div></div></li><li data-showlog="tid:136;cst:1;logInfo:related_news;" data-extralog="flow:2;rid:;pos:3;extra:;isBaiJiaHao:1;login:1;" data-rid="related_news_3"><div class="item-content clearfix"><div class="news-info"><div class="news-title"><h3><a class="upgrade" data-clklog="tid:148;cst:2;logInfo:related_news;" data-extralog="rid:;pos:3;extra:;isBaiJiaHao:1;login:1;type:&#39;title&#39;" href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_10237553350467197136%22%7D&amp;n_type=1&amp;p_from=4" target="_blank">天府新区：这里是面向未来的开放之窗</a></h3></div></div><div class="news-pic"><a class="upgrade" data-clklog="tid:148;cst:2;logInfo:related_news;" data-extralog="rid:;pos:4;extra:;isBaiJiaHao:1;login:1;type:&#39;img&#39;" href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_10237553350467197136%22%7D&amp;n_type=1&amp;p_from=4" target="_blank"><img src="./搞懂这些Redis知识点，吊打面试官！_files/u=2457237094,255700110&amp;fm=173&amp;app=49&amp;f=JPEG"></a></div></div></li></ul></div></div><div id="relateAd" ad-id="relate-js" class="wangmeng-ad" data-showlog="tid:369;cst:1;logInfo:adsjs;" data-clklog="tid:370;cst:2;logInfo:adsjs;" data-extralog="rid:;pos:4;extra:;baijiahao:1;login:1;"></div></div></div></div><div id="bottom-container" class="bottom-container "><div class="copy-right"><div class="baidu-info"><a class="sethome" href="https://www.baidu.com/cache/sethelp/index.html" target="_blank"><span>设为首页</span></a><span class="copyright-text"><span>©&nbsp;Baidu&nbsp;</span><a href="https://www.baidu.com/duty/" target="_blank">使用百度前必读</a>&nbsp;<a href="http://jianyi.baidu.com/" target="_blank">意见反馈</a>&nbsp;<span>京ICP证030173号&nbsp;</span><img width="13" height="16" src="./搞懂这些Redis知识点，吊打面试官！_files/copy_rignt_24.png"></span></div><div class="recordcode"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11000002000001" target="_blank"><i></i>京公网安备11000002000001号</a></div></div><div class="back-to-top" data-showlog="tid:133;cst:1;logInfo:back_to_top;" data-clklog="tid:138;cst:2;logInfo:back_to_top;" data-extralog="rid:;pos:;extra:;isBaiJiaHao:1;login:1;" data-rid="back_to_top" style="visibility: visible;"><div class="icon-text"><span>返回顶部</span></div><div class="icon-arrow"><span></span></div></div></div></div><script type="text/javascript">window.onload = function () {var contentContainer = document.getElementById('content-container');var bottomContainer = document.getElementById('bottom-container');var rightContainer = document.getElementById('right-container');var minContentHeight = window.innerHeight - bottomContainer.offsetHeight;if (contentContainer.offsetHeight < minContentHeight) {contentContainer.style.height = minContentHeight + 'px';bottomContainer.className += ' fixed';}if (rightContainer.children.length === 0) {rightContainer.style.width = parseInt(rightContainer.offsetWidth + 1, 10) + 'px';}};</script><script type="text/javascript" src="./搞懂这些Redis知识点，吊打面试官！_files/jquery_0affbc1.js.下载"></script><script type="text/javascript" src="./搞懂这些Redis知识点，吊打面试官！_files/land_min_pack_8e22d87.js.下载"></script><script type="text/javascript" src="./搞懂这些Redis知识点，吊打面试官！_files/index_bd58962.js.下载"></script></body></html>