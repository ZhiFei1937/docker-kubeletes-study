### 协程

问题点：协程与线程/进程之间的区别

```sh
- 1.进程是计算器最小资源分配单位
- 2.线程是CPU调度的最小单位
- 3.进程切换需要的资源很最大，效率很低
- 4.线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）
- 5.协程切换任务资源很小，效率高（协程本身并不存在，是程序员通过控制IO操作完成）
- 6.多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发

进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，开销大。

线程： 调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在一个进程至少有一个线程，叫主线程，而多个线程共享内存(数据共享，共享全局变量)，从而极大地提高了程序的运行效率。

协程：是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

 多进程的优点是稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程。但是缺点是创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源，并且，操作系统对进程的总数会有一定的限制，若进程过多，操作系统调度都会存在问题，会造成假死状态。
    多线程优点是效率较高一些，但是致命的缺点是任何一个线程崩溃都可能造成整个进程的崩溃，因为它们共享了进程的内存资源池。 对于任务数来说，无论是多进程或者多线程，都不能太多。因为操作系统在切换任务时，会有一系列的保护现场措施，这要花费相当的系统资源，若任务过多，则大部分资源都被用做干这些了，结果就是所有任务都做不好，所以操作系统会限制进程的数量。 另外，考虑计算密集型及IO密集型应用程序。对于计算密集型，多任务势必造成资源浪费。对于IO密集型，因为IO速度远低于CPU计算速度，所以使用多任务方式可以大大增大程序运行效率。
协程，又称微线程 英文名Coroutine

    协程是python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（理解为需要的资源）。 为啥说它是一个执行单元，因为它***自带CPU上下文***。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。
    在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。
    
   1. 采用同步的方式去编写异步的代码，使代码的可读性高，更简便
   2. 使用单线程去切换任务(就像单线程间函数之间的切换那样，速度超快)
   		(1) 线程是由操作系统切换的，单线程的切换意味着我们需要自己去调度任务
   		(2) 不需要锁，并发性高，如果单线程内切换函数，性能远高于线程切换，并发性更高
   		
对操作系统来说,创建一个线程的代价是十分昂贵的, 需要给它分配内存、列入调度,同时在线程切换的时候还要执行内存换页,CPU 的缓存被 清空,切换回来的时候还要重新从内存中读取信息,破坏了数据的局部性。

上下文切换：

概念：
当前任务执行一个时间片后会切换到下一个任务。在切换之前，上一个任务的状态会被保存下来，下次切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换。

说明：
1)时间片是CPU分配给各个线程的时间，时间片一般是几十毫秒。
2)CPU通过给每个线程分配CPU时间片，并且不停地切换线程来实现多线程。因为时间片非常短，所以感觉多个线程是在同时执行
```



字典为动词“to yield”给出了两个释义:**产出**和**让步**。对于 Python 生成器中的 yield 来说,这两个含义都成立。 yield item 这行代码会产出一个值,提供给 next(...) 的调用方;此外,还会作出让步,暂停执行生成器,让调用方继续工作,直到需要使用另一个值时再调用 next() 。调用方会从生成器中拉取值。

yield 都是一种**流程控制工具**,使用它可以实现协作式多任务:协程可以把控制器让步给中心调度程序,从而激活其他的协程。

协程是指一个过程,这个过程与调用方协作,产出由调用方提供的值。

协程可以身处四个状态中的一个。当前状态可以使用 inspect.getgeneratorstate(...) 函
数确定,该函数会返回下述字符串中的一个。
'GEN_CREATED'
等待开始执行。
'GEN_RUNNING'
解释器正在执行。 1
'GEN_SUSPENDED'
在 yield 表达式处暂停。
'GEN_CLOSED'
执行结束。

在赋值语句中, =右边的代码在赋值之前执行。因此,对于 b = yield a 这行代码来说,等到客户端代码再
激活协程时才会设定 b 的值。

```python
def averager():
    total = 0.0
    count = 0
    average = None
    while True:     
        term = yield average #average为产出，当协程暂停在这里时，
                             #通过send直接将值赋给term，然后产出average
        total += term
        count += 1
        average = total/count

if __name__ == '__main__':
    obj = averager()
    next(obj)   #激活协程
    print(obj.send(20))    #发送值给term，并产出average
```

使用 yield from 句法调用协程时,会自动预激

协程中未处理的异常会向上冒泡,传给 next 函数或 send 方法的调用方(即触发协程的对象)。

yield from x 表达式对 x 对象所做的第一件事是,调用 iter(x) ,从中获取迭代器。因此,x 可以是任何可迭代的对象。

yield from 的主要功能是打开双向通道,把最外层的调用方与最内层的子生成器连接起来,这样二者可以直接发送和产出值,还可以直接传入异常,而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构,协程可以通过以前不可能的方式委托职责。

线程与协程之间的比较还有最后一点要说明:如果使用线程做过重要的编程,你就知道写
出程序有多么困难,因为调度程序任何时候都能中断线程。必须记住保留锁,去保护程序
中的重要部分,防止多步操作在执行的过程中中断,防止数据处于无效状态。
而协程默认会做好全方位保护,以防止中断。我们必须显式产出才能让程序的余下部分运
行。对协程来说,无需保留锁,在多个线程之间同步操作,协程自身就会同步,因为在任
意时刻只有一个协程运行。想交出控制权时,可以使用 yield 或 yield from 把控制权交还
调度程序。这就是能够安全地取消协程的原因:按照定义,协程只能在暂停的 yield 处取
消,因此可以处理 CancelledError 异常,执行清理操作。