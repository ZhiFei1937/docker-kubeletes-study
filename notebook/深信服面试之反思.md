### 面试反思

#### 面试官的两次评价

基础不牢固，特别是网络和数据库方面，语言表达简练：

![深信服1面](D:\plan\notebook\深信服1面.png)

态度不端正，面试时嘻嘻哈哈，因而造成不靠谱的印象：

![深信服2面](D:\plan\notebook\深信服2面.png)

参考其他不通过的评价反思自己的不足：

![深信服他人的评价](D:\plan\notebook\深信服他人的评价.png)

#### 需要加强的点

- Python垃圾回收机制

  ```python
  对象绝不会自行销毁；当对象的引用计数为0或者无法得到对象时，可能会被当作垃圾回收。
  引用计数算法：
  	每个对象都会统计有多少引用指向自己，当引用计数归零时，对象立即就被销毁，CPython会在对象		上调用__del__方法(如果定义了)，然后释放分配给对象的内存。
      缺点：维护引用计数消套资源，无法解决循环引用带来的问题。
      循环引用的例子如下：
      a = [1] 
      b = [1] 
      a.append(b)
      b.append(a)#无论怎么释放，a、b引用计数都为1
  标记清除算法：
  	标记清除（Mark—Sweep）算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。
      主要处理的是一些容器对象，如list、dict、tuple
      主要有两个阶段：
      	1. 标记阶段，GC会把所有的活动对象打上标记
          2. 把那些没有标记的对象非活动对象进行回收
  	对象之间通过引用(指针)连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系         构成这个有向图的边。从根对象出发，沿着有向边遍历对象，可达对象标记为活动对象，不可达的       对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。
      但是清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象
      如下图：4和5将被释放。
  分代垃圾回收算法：
  	是建立在标记清除技术基础上的，是一种以空间换时间的操作。
    	Python将根据对象的存活时间划分成不同的集合，一般为3“代”(年轻代、中年代、老年代)对应3个链表，垃圾收集频率与对象的存活时间的增大而减少。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，就触发Python垃圾收集机制，把那些可以回收的对象回收掉，而不会回收的对象就会被移到中年代去，以此类推，老年代中的对象是存活最久的对象。
  ```

  ![mark-sweep](D:\plan\notebook\picture\mark-sweep.svg)

- 进程、线程、协程的使用、原理与区别

  ```sh
  "进程"：操作系统资源分配的最小单位，在操作系统中，每一个独立运行的程序，都占有操作系统分配的资源，这些程序中间互不干涉，都只负责运行自己的程序代码。
  "线程"：CPU的最小调度单位，当多线程出现在一个进程中时，多个线程之间共享此进程的资源，并接受操作系统的调度来运行每个线程。
  "并发"：异步非阻塞状态，并发的关键，当主程序使用异步I/O操作时，并不会影响主程序后续的运行，而当异步I/O操作完成后，会主动通知主程序进行其他操作，这样就减少了轮询过程中的资源消耗，专注于其他工作。
  "协程"：协程并不是操作系统层面存在的一种程序，协程是程序级别的，由程序编写者自己操控整个协程的生命周期，这样可以实现类似操作系统中多线程一样的效果，但是省下了线程切换过程中造成的资源消耗。
  "信号量"：可以理解为多把锁，同时允许多个线程来更改数据。而互斥锁同时只允许一个线程来更改数据。
  ```

- 如何去调节协程

  ```python
  import asyncio
  import time
  
  
  async def test(num):
      await asyncio.sleep(num)
      print(num)
  
  
  async def run():
      tasks = [asyncio.create_task(test(num)) for num in range(4)]
      [await t for t in tasks]
  
  
  def run_main():
      asyncio.run(run())
  
  
  if __name__ == "__main__":
      run_main()
  ```

- Python元类编程及元类的定义

  ```sh
  元类是类元编程最高级的工具：使用元类可以创建具有某种特质的全新种类，例如抽象基类。
  元类：制造类的工厂，是一个类而不是一个函数。
  类工厂函数：collections.namedtuple。把一个类名和几个属性名传给这个函数，它会创建一个tuple的			 子类，其中的元素通过名称获取。
  type是大多数内置的类和用户定义的类和元类
  元类从type类继承了构建类的能力，所有类都是type的实例，但是元类还是type的子类，因此可以作为制造类的工厂。具体来说，元类可以通过实现__init__方法定制实例。元类的__init__方法可以做到类装饰器能做的如何事情，但是作用更大。
  ```

- 操作系统性能方面的了解

  ```sh
  如free中buff/cache的含义及理解，以及这片内存的用途
  指：被buffer和cache使用的物理内存大小。
  buffer：在操作系统中指buffer cache(缓冲区)，扇区是设备的最小寻址单元，也叫“硬扇区”或“设备块”。块是操作系统中文件系统的最小寻址单元，也叫“文件块”或“I/O块”。每个块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示。
  
  注意，buffer cache 只有块的概念而没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟存放的是什么格式的文件。
  
  cache 在操作系统中指 page cache，中文一般翻译为 "页高速缓存"。页高速缓存是内核实现的磁盘缓存。它主要用来减少对磁盘的 I/O 操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。页高速缓存缓存的是内存页面。缓存中的页来自对普通文件、块设备文件(这个指的就是 buffer cache 呀)和内存映射文件的读写。
  页高速缓存对普通文件的缓存我们可以这样理解：当内核要读一个文件(比如 /etc/hosts)时，它会先检查这个文件的数据是不是已经在页高速缓存中了。如果在，就放弃访问磁盘，直接从内存中读取。这个行为称为缓存命中。如果数据不在缓存中，就是未命中缓存，此时内核就要调度块 I/O 操作从磁盘去读取数据。然后内核将读来的数据放入页高速缓存中。这种缓存的目标是文件系统可以识别的文件(比如 /etc/hosts)。
  页高速缓存对块设备文件的缓存就是我们在前面介绍的 buffer cahce。因为独立的磁盘块通过缓冲区也被存入了页高速缓存(缓冲区最终是由页高速缓存来承载的)。
  
  到这里我们应该搞清楚了：无论是缓冲区还是页高速缓存，它们的实现方式都是一样的。缓冲区只不过是一种概念上比较特殊的页高速缓存罢了。
  ```

- IO多路复用模型的理解

  ```sh
  服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：
  1、同步阻塞IO(Blocking IO)
  2、同步非阻塞IO(Non-blocking IO)
  3、IO多路复用(IO Multiplexing)
  	很多个网络IO复用一个或少量的线程来处理这些连接
  	select机制
      基本原理：
        客户端操作服务器时就会产生这三种文件描述符(简称fd)：writefds(写)、readfds(读)、和			  exceptfds(异常)。select会阻塞住监视3类文件描述符，等有数据、可读、可写、出异常 或超时、就会       返回；返回后通过遍历fdset整个数组来找到就绪的描述符fd，然后进行对应的IO操作。
      优点：
        几乎在所有的平台上支持，跨平台支持性好
      缺点：
        由于是采用轮询方式全盘扫描，会随着文件描述符FD数量增多而性能下降。
        每次调用 select()，需要把所有的 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到		  用户空间)
        默认单个进程打开的FD有限制是1024个，可修改宏定义，但是效率仍然慢。
  	每过一段时间就从所有监听的fd中找一下已经就绪的文件描述符，然后通知线程进行IO操作
      poll机制:
        基本原理与select一致，也是轮询+遍历；唯一的区别就是poll没有最大文件描述符限制（使用链表的方式		存储fd）。
      epoll机制：
        基本原理：
          fd最大数量由最大可以打开文件的数目决定，用户态拷贝到内核态只需要一次，使用时间通知机制来触			发。通过epoll_ctl注册fd，一旦fd就绪就会通过callback回调机制来激活对应fd，进行相关的io操		作。
          epoll之所以高性能是得益于它的三个函数
            1)epoll_create()系统启动时，在Linux内核里面申请一个B+树结构文件系统，返回epoll对象，也             是一个fd
            2)epoll_ctl() 每新建一个连接，都通过该函数操作epoll对象，在这个对象里面修改添加删除对应             的链接fd, 并为其绑定一个callback函数，当就绪时，会调用回调函数，把就绪的fd和事件加入一			  个就绪链表，并拷贝到用户空间内存，应用程序不用亲自从内核拷贝
            3)epoll_wait() 监听epoll_ctl中注册的fd，在就绪链表中查看有没有就绪的fd，不用遍历所有的			   fd，并完成对应的IO操作
        优点：
          没fd这个限制，所支持的FD上限是操作系统的最大文件句柄数，1G内存大概支持10万个句柄
          效率提高，使用回调通知而不是轮询的方式，不会随着FD数目的增加效率下降
          内核和用户空间mmap同一块内存实现(mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射            到进程的地址空间)
  
      例子：100万个连接，里面有1万个连接是活跃，我们可以对比 select、poll、epoll 的性能表现
        select：不修改宏定义默认是1024,l则需要100w/1024=977个进程才可以支持 100万连接，会使得CPU性		   能特别的差。
        poll：    没有最大文件描述符限制,100万个链接则需要100w个fd，遍历都响应不过来了，还有空间的拷	     消耗大量的资源。
        epoll:    最大请求进来时就创建fd并绑定一个callback，主需要遍历1w个活跃连接的callback即可，		  即高效又不用内存拷贝。
      select/poll在函数返回后需要查看所有监听的fd，看那些就绪，而epoll只返回就绪的描述符，所以应用程	序只需要就绪fd的命中率是百分百。
  4、异步IO(Asynchronous IO)
  同步和异步的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。
  阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。
  ```

- TCP状态机

   [彻底搞定_手绘TCP状态机.html](picture\彻底搞定_手绘TCP状态机.html) 

  ![tcp三次握手](D:\plan\notebook\picture\tcp三次握手.webp)

  当一个TCP连接建立时，发生了以下事情：

  1. 服务端必须准备接收传入的连接。这通常通过调用`socket`，`bind`和`listen`来完成，称为被动打开。
  2. 客户端通过调用`connect`方法来发起一个主动的打开。客户端TCP会发送一个“同步”(SYN)段，它告诉服务器客户端在连接上发送的数据的**初始序列号**。通常情况下，SYN没有发送数据，它只包含一个IP头，TCP头和可能的TCP选项。
  3. 服务器必须确认（ACK）客户端的SYN，并且服务器还必须发送自己的SYN，其中包含服务器将在连接上发送的数据的初始序列号。
  4. 客户端必须确认服务器的SYN。

  ```sh
  TCP状态及其描述如下表：
  状态		   描述
  LISTEN		等待来自远程TCP应用程序的请求
  SYN_SENT	发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态
  SYN-RECEIVED	该端点已经接收到连接请求并发送确认。
  				该端点正在等待最终确认。TCP第二次握手后服务端所处的状态
  ESTABLISHED	代表连接已经建立起来了。这是连接数据传输阶段的正常状态
  FIN_WAIT_1	等待来自远程TCP的终止连接请求或终止请求的确认
  FIN_WAIT_2	在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求
  CLOSE_WAIT	该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求
  CLOSING		等待来自远程TCP的连接终止请求确认
  LAST_ACK	等待先前发送到远程TCP的连接终止请求的确认
  TIME_WAIT	等待足够的时间来确保远程TCP接收到其连接终止请求的确认
  ```

- 数据库的扩展

   [搞懂这些Redis知识点，吊打面试官！.html](picture\搞懂这些Redis知识点，吊打面试官！.html) 

  ```sh
  Redis数据库：
  	redis是C语言开发的一个开源的(遵从BSD协议)高性能键值对(key-value)的内存数据库，可以用于数据库、缓存、消息中间件等。是一种NoSQL的数据库。
  	redis作为一个内存数据库，性能优秀，数据在内存中，读写速度非常快，支持并发10W QPS。单进程单线程，是线程安全的，采用IO多路复用机制。丰富的数据类型，支持字符串(strings)、散列(hashes)、列表(lists)、集合(sets)、集合(sets)、有序集合(sorted sets)等。支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载。主从复制，哨兵，高可用。可以用作分布式锁。可以作为消息中间件使用，支持发布订阅。
  ```

- 不同数据库的比较

  ```sh
  MySQL/Postgres底层原理的不同之处
  1、MySQL只有InnoDB等少量存储引擎遵从ACID，而postgres完全遵从ACID
  2、PostgreSQL是遵从SQL标准支持最好的数据库。
  3、pg既支持OLTP场景也支持OLAP场景，混合性业务场景，能更好的支持JSON文档型业务场景
  4、MySQL只支持OLTP场景大型数据库支持存在一定的困难
  5、pg是物理复制，复制延迟小，主备库之间数据绝地一致，也支持逻辑复制，支持一主多从，级联复制
  6、MySQL仅支持逻辑复制，主备库之间数据一致比较困难，支持一主多从，级联复制，双master
  查询相关功能对比：
  	pg有成熟的基于代价的SQL优化器，复杂SQL性能很好，可以走多个索引，表增加列只是在数据字典中增		加表定义，不会重建表，支持并行查询
  	MySQL大部分时间只能使用单一索引，表增加列基本上是重建表和索引，不支持并行查询
  7、pg支持外部表功能，是堆表，不支持索引组织表。MySQL是索引组织表，不支持堆表
  8、MySQL是单进程多线程架构，pg是多进程架构
  9、pg支持物化视图，而MySQL不支持，pg支持类型扩展，而MySQL不支持，pg支持丰富的认证方法。
  pg和MySQL是从底层设计原理开始就不一样的两种数据库，在数据量小的时候，数据库更趋于轻量化，MySQL更合适，但pg适合大的数据量，多的计算量。
  ```

- 数据库基础知识

  ```sh
  事务：逻辑上的一组操作，要么都执行，要么都不执行
  ACID的定义：
  	原子性(Atomic)：事务是最小的执行单位，不允许分割。要么全部完全，要么完全不起作用
  	一致性(Consistency)：执行事务前后，数据库状态保持一致，比如数据库完整性约束、日志状态、索						   引和数据的一致，即事务完成后，数据库的一切都是OK的
  	隔离性(Isolcation)：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据						  库都是独立的。
  	持久性(Durability)：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生异常						  时也不应该对其有任何影响。
  并发事务带来的问题：
  1、脏读(Dirty read)：当一个事务读取了另外一个事务修改了但是还没有提交的数据。
  2、丢失修改(Lost to modify)：两个需要修改同一处数据的事务同时读取了这个数据并依次对其进行修改
  	如：原数据为20，两个事务都要对其进行减一的操作，最终结果为19
  3、不可重复读(Unrepeatableread)：指在一个事务内多处读同一个数据，但是在其没有执行完时有一个数	据对其进行了"修改"，导致前后两次读到的数据不一致
  4、幻读(Phantom read)：幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事	  务"插入"了一些数据时。
  事务隔离级别：
  1、READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏		读、幻读或不可重复读。
  2、READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可		重复读仍有可能发生。
  3、REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所	修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
  4、SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，	这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
  ```

- 乐观锁与悲观锁的区别

  ```sh
  悲观锁
  总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
  
  乐观锁
  总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。
  
  两种锁的使用场景
  从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
  ```

- 操作系统安全与web安全

  ```sh
  
  ```

- 算法方面的加强

  ```sh
  
  ```

  