### 继承的优缺点

python中继承与C++中的不同点

- 子类化内置类型的缺点
- 多重继承和方法解析顺序

原生类型的这种行为违背了面向对象编程的一个基本原则:始终应该从实例( self )所属的类开始搜索方法,即使在超类实现的类中调用也是如此。在这种糟糕的局面中,__missing__ 方法却能按预期方式工作,不过这只是特例。不只实例内部的调用有这个问题( self.get() 不调用 self.__getitem__() ),内置类型的方法调用的其他类的方法,如果被覆盖了,也不会被调用

直接子类化内置类型(如 dict 、 list 或 str )容易出错,因为内置类型的方法通常会忽略用户覆盖的方法。不要子类化内置类型,用户自己定义的类应该继承 collections 模块中的类,例如 UserDict 、 UserList 和 UserString ,这些类做了特殊设计,因此易于扩展。

上述问题只发生在 C 语言实现的内置类型内部的方法委托上,而且只影响直接继承内置类型的用户自定义类。如果子类化使用 Python 编写的类,如 UserDict 或MutableMapping ,就不会受此影响。

类都有一个名为 __mro__ 的属性,它的值是一个元组,按照方法解析顺序列出各个超类,从当前类一直向上,直到
object 类。(<class 'diamond.D'>, <class 'diamond.B'>, <class 'diamond.C'>,<class 'diamond.A'>, <class 'object'>)

使用多重继承时,一定要明确一开始为什么创建子类。主要原因可能有:

- 继承接口,创建子类型,实现“是什么”关系
- 继承实现,通过重用避免代码重复

如果类的作用是定义接口,应该明确把它定义为抽象基类。

如果一个类的作用是为多个不相关的子类提供方法实现,从而实现重用,但不体现“是什么”关系,应该把那个类明确地定义为混入类(mixin class)。从概念上讲,混入不定义新类型,只是打包方法,便于重用。混入类绝对不能实例化,而且具体类不能只继承混入类。混入类应该提供某方面的特定行为,只实现少量关系非常紧密的方法。

如果抽象基类或混入的组合对客户代码非常有用,那就提供一个类,使用易于理解的方式把它们结合起来。

### Python风格的对象

- 如何以及何时使用 @classmethod 和 @staticmethod 装饰器
- Python 的私有属性和受保护属性的用法、约定和局限

repr() 以便于***开发者***理解的方式返回对象的字符串表示形式。
str()    以便于***用户***理解的方式返回对象的字符串表示形式。

classmethod定义操作类,而不是操作实例的方法。classmethod 改变了调用方法的方式,因此类方法的第一个参数是类本身,而不是实例。classmethod 最常见的用途是定义备选构造方法

staticmethod 装饰器也会改变方法的调用方式,但是第一个参数不是特殊的值。其实,静态方法就是普通的函数,只是碰巧在类的定义体中,而不是在模块层定义。

Python 在各个实例中名为 __dict__ 的字典里存储实例属性。为了使用底层的散列表提升访问速度,字典会消耗大量内存。如果要处理数百万个属性不多的实例,通过 __slots__ 类属性,能节省大量内存,方法是让解释器在元组中存储实例属性,而不用字典。

**弱引用**不会增加对象的引用数量

